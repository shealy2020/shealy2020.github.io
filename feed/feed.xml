<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet href="pretty-atom-feed.xsl" type="text/xsl"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
  <title>Merge</title>
  <subtitle>Navigating the intersections of technical communication and AI</subtitle>
  <link href="https://shealy2020.github.io/feed/feed.xml" rel="self" />
  <link href="https://shealy2020.github.io/" />
  <updated>2025-10-27T00:00:00Z</updated>
  <id>https://shealy2020.github.io/</id>
  <author>
    <name>Sean Healy</name>
  </author>
  <entry>
    <title>Setting up Local RAG Pipeline in Docker</title>
    <link href="https://shealy2020.github.io/posts/local-rag-in-docker/" />
    <updated>2025-10-27T00:00:00Z</updated>
    <id>https://shealy2020.github.io/posts/local-rag-in-docker/</id>
    <content type="html">&lt;p&gt;This project is a prototype of a local Retrieval-Augmented Generation (RAG) system, exploring how RAG pipelines work. It was a useful step before scaling or adapting it to production environments, where proprietary information is behind a firewall. Everything runs entirely on a local pc and requires no cloud services or external data transfers. I used open-source tools only — Python, Chroma, Sentence Transformers, and Ollama.&lt;/p&gt;
&lt;p&gt;You&#39;ll find the package on &lt;a href=&quot;https://github.com/shealy2020/rag-local&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;prerequisites&quot;&gt;Prerequisites&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Windows 11 with WSL 2&lt;/li&gt;
&lt;li&gt;Docker Desktop installed with WSL enabled&lt;/li&gt;
&lt;li&gt;Python installed&lt;/li&gt;
&lt;li&gt;At least 4GB RAM available&lt;/li&gt;
&lt;li&gt;At least 5GB disk space&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;rag-pipeline-components&quot;&gt;RAG Pipeline Components&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;LLM&lt;/strong&gt;: Gemma 2B (via Ollama)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Embeddings&lt;/strong&gt;: all-MiniLM-L6-v2&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Vector Store&lt;/strong&gt;: ChromaDB&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Interface&lt;/strong&gt;: Flask + HTML&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Supported Formats&lt;/strong&gt;: Markdown (.md), HTML (.html, .htm)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;privacy-and-security&quot;&gt;Privacy &amp;amp; Security&lt;/h2&gt;
&lt;p&gt;This pipeline is a prototype. It provides basic safeguards but is not production ready.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All data stays on your machine&lt;/li&gt;
&lt;li&gt;No external API calls after setup&lt;/li&gt;
&lt;li&gt;No telemetry or analytics&lt;/li&gt;
&lt;li&gt;Can run with complete network isolation&lt;/li&gt;
&lt;li&gt;Docker container isolation&lt;/li&gt;
&lt;li&gt;API Key for extra layer of security&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;summary-of-python-scripts&quot;&gt;Summary of Python Scripts&lt;/h2&gt;
&lt;h3 id=&quot;1-config-py-configuration-management&quot;&gt;&lt;strong&gt;1. config.py&lt;/strong&gt; - Configuration Management&lt;/h3&gt;
&lt;p&gt;Central configuration file that defines all system settings:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Paths&lt;/strong&gt;: Input documents, ChromaDB storage, model cache locations&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Models&lt;/strong&gt;: Uses &lt;code&gt;sentence-transformers/all-MiniLM-L6-v2&lt;/code&gt; for embeddings and &lt;code&gt;gemma:2b&lt;/code&gt; via Ollama for text generation&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Chunking&lt;/strong&gt;: Documents split into 512-character chunks with 50-character overlap&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Retrieval&lt;/strong&gt;: Retrieves top 5 most similar chunks with 0.7 similarity threshold&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Server&lt;/strong&gt;: Flask runs on port 5000&lt;/li&gt;
&lt;li&gt;Uses environment variables for flexibility in deployment&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&quot;2-ingest-py-document-processing-and-indexing&quot;&gt;&lt;strong&gt;2. ingest.py&lt;/strong&gt; - Document Processing &amp;amp; Indexing&lt;/h3&gt;
&lt;p&gt;Handles the ingestion pipeline that prepares documents for retrieval:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DocumentProcessor class:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Reads Markdown and HTML files&lt;/li&gt;
&lt;li&gt;Converts them to plain text (strips formatting, scripts, styles)&lt;/li&gt;
&lt;li&gt;Splits text into overlapping chunks for better context preservation&lt;/li&gt;
&lt;li&gt;Creates unique IDs for each chunk using MD5 hashing&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;VectorStore class:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Manages ChromaDB persistent storage&lt;/li&gt;
&lt;li&gt;Generates embeddings using SentenceTransformer&lt;/li&gt;
&lt;li&gt;Stores document chunks with their vector embeddings&lt;/li&gt;
&lt;li&gt;Provides collection statistics and reset functionality&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Main workflow:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Scans input directory for &lt;code&gt;.md&lt;/code&gt;, &lt;code&gt;.html&lt;/code&gt;, &lt;code&gt;.htm&lt;/code&gt; files&lt;/li&gt;
&lt;li&gt;Processes each file into chunks&lt;/li&gt;
&lt;li&gt;Generates embeddings in batches (100 at a time)&lt;/li&gt;
&lt;li&gt;Stores everything in ChromaDB for efficient similarity search&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&quot;3-query-py-query-processing-engine&quot;&gt;&lt;strong&gt;3. query.py&lt;/strong&gt; - Query Processing Engine&lt;/h3&gt;
&lt;p&gt;The core RAG logic that answers user questions:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RAGEngine class:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Retrieval&lt;/strong&gt;: Converts user questions to embeddings and finds similar document chunks using vector search&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Context Building&lt;/strong&gt;: Assembles retrieved chunks with source attribution&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Response Generation&lt;/strong&gt;: Uses Ollama LLM with a structured prompt that instructs it to answer based only on provided context&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Error Handling&lt;/strong&gt;: Gracefully handles missing collections or empty databases&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Query flow:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Embed the user&#39;s question&lt;/li&gt;
&lt;li&gt;Find top-K most similar document chunks&lt;/li&gt;
&lt;li&gt;Build context from retrieved chunks&lt;/li&gt;
&lt;li&gt;Send context + question to LLM&lt;/li&gt;
&lt;li&gt;Return answer with source citations&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&quot;4-server-py-web-api-server&quot;&gt;&lt;strong&gt;4. server.py&lt;/strong&gt; - Web API Server&lt;/h3&gt;
&lt;p&gt;Flask-based web server that exposes the RAG system via HTTP:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Features:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;API Key Authentication&lt;/strong&gt;: Optional security via &lt;code&gt;X-API-Key&lt;/code&gt; header (controlled by &lt;code&gt;RAG_API_KEY&lt;/code&gt; environment variable)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Three endpoints:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GET /&lt;/code&gt; - Serves the web interface&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GET /api/status&lt;/code&gt; - Returns system health (document count, available files, readiness)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;POST /api/query&lt;/code&gt; - Processes questions and returns AI-generated answers&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Lazy Loading&lt;/strong&gt;: RAG engine initialized on first query for faster startup&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Error Handling&lt;/strong&gt;: Comprehensive error responses with appropriate HTTP status codes&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Authentication decorator&lt;/strong&gt; ensures protected endpoints require valid API keys when enabled.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;system-architecture&quot;&gt;System Architecture&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;User Question → Flask Server → RAG Engine → ChromaDB (Vector Search)
                                    ↓
                            Retrieved Chunks
                                    ↓
                            Ollama LLM (gemma:2b)
                                    ↓
                            Answer + Sources → User
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;installation-and-setup&quot;&gt;Installation &amp;amp; Setup&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Start Docker Desktop in Windows.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Start WSL. A Bash terminal opens in your home directory.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Copy &lt;em&gt;rag-local&lt;/em&gt; directory to your home directory.&lt;/p&gt;
&lt;p&gt;Project Structure:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rag-local/
├── Dockerfile              # Container definition
├── docker-compose.yml      # Docker Compose configuration
├── requirements.txt        # Python dependencies
├── README.md              # This file
├── app/
│   ├── config.py          # Configuration settings
│   ├── ingest.py          # Document ingestion
│   ├── query.py           # RAG query engine
│   ├── server.py          # Flask web server
│   ├── templates/
│   │   └── index.html     # Web interface
│   └── static/
│       └── style.css      # CSS styling
└── data/
 ├── input/             # Your documents (add files here)
 ├── chroma_db/         # Vector database (auto-created)
 └── models/            # Cached ML models (auto-created)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The project contains a sample &lt;code&gt;.md&lt;/code&gt; and &lt;code&gt;.html&lt;/code&gt; file in the &lt;em&gt;data/input&lt;/em&gt; directory.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Generate an API Key.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&quot;language-bash&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;openssl rand &lt;span class=&quot;token parameter variable&quot;&gt;-base64&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;32&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This key will add a minimal security layer.&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;
&lt;p&gt;Copy the API Key. You will need it for the steps that follow. (Also, retain it for later use.)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Open &lt;em&gt;docker-compose.yml&lt;/em&gt; and find the following line:
&lt;em&gt;RAG_API_KEY=change-this-to-a-strong-random-key&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Replace &amp;quot;change-this-to-a-strong-random-key&amp;quot; with your API key.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Navigate to the project directory.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&quot;language-bash&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token builtin class-name&quot;&gt;cd&lt;/span&gt; ~/rag-local&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;9&quot;&gt;
&lt;li&gt;Build the Docker image.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&quot;language-bash&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;docker-compose&lt;/span&gt; build&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	This may take 10-20 minutes as it downloads all required components.&lt;/p&gt;
&lt;ol start=&quot;10&quot;&gt;
&lt;li&gt;Start the container.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&quot;language-bash&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;docker-compose&lt;/span&gt; up &lt;span class=&quot;token parameter variable&quot;&gt;-d&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	The first startup after a build may take 5-10 minutes as it downloads the Gemma 2B model (~1.7GB).&lt;/p&gt;
&lt;ol start=&quot;11&quot;&gt;
&lt;li&gt;Open a browser and enter:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;http://localhost:5000
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;12&quot;&gt;
&lt;li&gt;
&lt;p&gt;At the prompt, enter the API key you copied earlier, then click &lt;strong&gt;OK&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;The RAG interface opens (Flask + HTML) where you can query against the Markdown and HTML input files.&lt;/p&gt;
&lt;p&gt;The interface also provides commands to add and update input files.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;useful-docker-commands&quot;&gt;Useful Docker Commands&lt;/h2&gt;
&lt;pre class=&quot;language-bash&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;# Start the container&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;docker-compose&lt;/span&gt; up

&lt;span class=&quot;token comment&quot;&gt;# Start in background (-d = detached mode)&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;docker-compose&lt;/span&gt; up &lt;span class=&quot;token parameter variable&quot;&gt;-d&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;# Stop the container&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;docker-compose&lt;/span&gt; down

&lt;span class=&quot;token comment&quot;&gt;# View logs (-f = follow)&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;docker-compose&lt;/span&gt; logs &lt;span class=&quot;token parameter variable&quot;&gt;-f&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;# Rebuild after code changes&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;docker-compose&lt;/span&gt; build --no-cache
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;troubleshooting&quot;&gt;Troubleshooting&lt;/h2&gt;
&lt;h3 id=&quot;container-wont-start&quot;&gt;Container won&#39;t start&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Check to verify that Docker Desktop is running&lt;/li&gt;
&lt;li&gt;In Docker Desktop, go to &lt;strong&gt;Settings&lt;/strong&gt; &amp;gt; &lt;strong&gt;General&lt;/strong&gt;. Verify that &lt;em&gt;Use the WSL 2 based engine&lt;/em&gt; is enabled&lt;/li&gt;
&lt;li&gt;Check port 5000 is not in use: &lt;code&gt;netstat -an | grep 5000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;View logs: &lt;code&gt;docker-compose logs&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;ollama-errors&quot;&gt;Ollama errors&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Wait longer on first startup (model download takes time)&lt;/li&gt;
&lt;li&gt;Check container logs: &lt;code&gt;docker-compose logs | grep ollama&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Restart container: &lt;code&gt;docker-compose restart&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;out-of-memory&quot;&gt;Out of memory&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Reduce &lt;code&gt;TOP_K&lt;/code&gt; in &lt;code&gt;app/config.py&lt;/code&gt; (default: 5)&lt;/li&gt;
&lt;li&gt;Reduce &lt;code&gt;CHUNK_SIZE&lt;/code&gt; in &lt;code&gt;app/config.py&lt;/code&gt; (default: 512)&lt;/li&gt;
&lt;li&gt;Close other applications&lt;/li&gt;
&lt;li&gt;Restart Docker Desktop&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;slow-responses&quot;&gt;Slow responses&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This is normal for CPU-only inference with limited pc resources&lt;/li&gt;
&lt;li&gt;Gemma 2B on CPU typically takes 10-30 seconds per response&lt;/li&gt;
&lt;li&gt;Consider reducing the amount of context retrieved (TOP_K)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;configuration&quot;&gt;Configuration&lt;/h2&gt;
&lt;p&gt;Edit &lt;code&gt;app/config.py&lt;/code&gt; to customize:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;CHUNK_SIZE &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;512&lt;/span&gt;          &lt;span class=&quot;token comment&quot;&gt;# Size of text chunks&lt;/span&gt;
CHUNK_OVERLAP &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;50&lt;/span&gt;        &lt;span class=&quot;token comment&quot;&gt;# Overlap between chunks&lt;/span&gt;
TOP_K &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;                 &lt;span class=&quot;token comment&quot;&gt;# Number of chunks to retrieve&lt;/span&gt;
SIMILARITY_THRESHOLD &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0.7&lt;/span&gt;  &lt;span class=&quot;token comment&quot;&gt;# Minimum similarity score&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
</content>
  </entry>
  <entry>
    <title>Finding Semantically Similar Content</title>
    <link href="https://shealy2020.github.io/posts/finding-similar-content/" />
    <updated>2025-10-09T00:00:00Z</updated>
    <id>https://shealy2020.github.io/posts/finding-similar-content/</id>
    <content type="html">&lt;p&gt;A common problem with technical documentation management is that documentation teams tend to have a lot of stressed-out contributors working on shared content, scattered across multiple departments and revised over an extended period. This is a recipe for content bloat and redundancy.&lt;/p&gt;
&lt;p&gt;All content needs some degree of custodial refactoring through &lt;a href=&quot;https://en.wikipedia.org/wiki/Data_deduplication&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;deduplication&lt;/a&gt;, merging similar content into a single source of truth &lt;a href=&quot;https://en.wikipedia.org/wiki/Single_source_of_truth&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;(SSOT)&lt;/a&gt; or by eliminating all but one permutation. Even before the emergence of AI, maintaining clean, unambiguous documentation was essential to avoid the junk in/out scenario. In the foreseeable future, documentation will converted to vectors wholesale,&lt;/p&gt;
&lt;p&gt;Eventually, I&#39;d like to contain a large set of documentation in a local LLM that can be searched for semantically similar content. A human would need to determine the best course of action on a case-by-case basis. In taking baby steps toward that goal, I came across &lt;a href=&quot;https://github.com/neuml/txtai&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;txtai&lt;/a&gt; and put together a prototype that surfaces semantically same or similar chunks in the form of a report, using a simple Markdown file as input.&lt;/p&gt;
&lt;p&gt;The processing is straightforward:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;preprocess_markdown.py&lt;/strong&gt; - Chunks MD by heading to populate a JSON file.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;index_chunks.py&lt;/strong&gt; - txtai (sentence-transformers/all-MiniLM-L6-v2) indexes JSON file.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;report_similarity.py&lt;/strong&gt; - txtai compares paragraph vectors. Reports similarity clusters and vector scores.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If you want to look under the hood, you&#39;ll find this package on &lt;a href=&quot;https://github.com/shealy2020/single-md-txtai-report&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;postmortem&quot;&gt;Postmortem&lt;/h3&gt;
&lt;p&gt;I set out to use the hierarchical structure of the Markdown file as added context to vector scores, which was proved to be too ambitious for this first pass. Instead, I fell back to just comparing paragraph content under each Markdown heading. In retrospect, I might as well have done similarity searches across text in a *.txt file. Ultimately, my goal is to leverage what I&#39;ve learned about comparing vectorized MD chunks and then apply it to &lt;a href=&quot;https://en.wikipedia.org/wiki/Darwin_Information_Typing_Architecture&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;DITA&lt;/a&gt;, which is a highly structured authoring XML format with a lot of tagging and other metadata that could be contributing vector dimensions.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>LLM Prompt Organizer</title>
    <link href="https://shealy2020.github.io/posts/llm-prompt-org/" />
    <updated>2025-09-20T00:00:00Z</updated>
    <id>https://shealy2020.github.io/posts/llm-prompt-org/</id>
    <content type="html">&lt;p&gt;I use the free versions of LLMs like ChatGPT, Claude, and Gemini that impose limits on a per session basis. LLMs calculate these limits through some combination of request counts and &lt;a href=&quot;https://shealy2020.github.io/posts/prompt-efficiencies/#tokens&quot;&gt;token use&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In an earlier post, I provided some general guidelines on how to increase &lt;a href=&quot;https://shealy2020.github.io/posts/prompt-efficiencies/&quot;&gt;prompt efficiencies&lt;/a&gt; with the goal of conserving tokens. For this project, I take &amp;quot;token conservation&amp;quot; further by building a tool that helps to organize the initial LLM prompt, then it generates a JSON file as input for the LLM. The tool reduces the overall number of input tokens by streamlining the query into a clear set of prompt instructions.&lt;/p&gt;
&lt;p&gt;Initially, I used highly structured XML as the output container but thought better of it. Instead, I went with semi-structured JSON because its syntax uses fewer characters, thus fewer tokens. Also, this project gave me another opportunity to use &lt;a href=&quot;https://en.wikipedia.org/wiki/Vibe_coding&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vibe coding&lt;/a&gt; as an aid in building this prompt tool, which I&#39;ll write about in a future post.&lt;/p&gt;
&lt;p&gt;For your own use, you&#39;ll find the &lt;a href=&quot;https://github.com/shealy2020/llm-prompt-organizer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LLM Prompt Organizer on GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;llm-session-limits&quot;&gt;LLM Session Limits&lt;/h2&gt;
&lt;p&gt;This table contains approximate limitation criteria for non-subscription users.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Service&lt;/th&gt;
&lt;th&gt;Key Usage Limits&lt;/th&gt;
&lt;th&gt;Approx. Token / Context Window&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;ChatGPT&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Limited GPT-4o usage per ~5-hour window.&lt;/td&gt;
&lt;td&gt;~128k tokens (input + output).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Claude&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Message/session limit, resets ~every 5 hrs.&lt;/td&gt;
&lt;td&gt;~200k tokens (input + output).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Gemini&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;~2 req/min, ~50 req/day (API); ~5 prompts/day (app).&lt;/td&gt;
&lt;td&gt;Up to ~1M input / 65K output tokens.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;why-use-this-tool&quot;&gt;Why Use This Tool?&lt;/h2&gt;
&lt;h3 id=&quot;the-problem-with-unstructured-prompts&quot;&gt;The Problem with Unstructured Prompts&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Important context gets buried in long text blocks.&lt;/li&gt;
&lt;li&gt;Reusing successful prompt patterns requires copy-pasting and manual editing.&lt;/li&gt;
&lt;li&gt;No clear separation between instructions, context, constraints, and data.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;the-solution-semi-structured-prompts&quot;&gt;The Solution: Semi-structured Prompts&lt;/h3&gt;
&lt;p&gt;The LLM Prompt Organizer helps you create reusable prompts by:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Separating concerns&lt;/strong&gt; - Breaks your prompt into logical components (role, context, task, format, etc.)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ensuring completeness&lt;/strong&gt; - Visual interface reminds you of all the elements that make prompts effective&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Enabling reusability&lt;/strong&gt; - Saves JSON files as templates for similar tasks.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Improving clarity&lt;/strong&gt; - JSON&#39;s semi-structured format helps the LLM understand the request.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Supporting iteration&lt;/strong&gt; - Users can easily modify specific sections without rewriting everything.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;quick-start&quot;&gt;Quick Start&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Download the &lt;code&gt;prompt-form-output json-1.html&lt;/code&gt; file from &lt;a href=&quot;https://github.com/shealy2020/llm-prompt-organizer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Open the form in a browser.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://shealy2020.github.io/images/prompt-organizer-form-1.png&quot; alt=&quot;Prompt Organizer&quot; title=&quot;Prompt Organizer&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If you don&#39;t need customizations, add content to the default fields.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Export your prompt by clicking &lt;strong&gt;Copy JSON&lt;/strong&gt; or &lt;strong&gt;Download JSON&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Enter your JSON data into the chatbot&#39;s query field by either pasting the text into the field or by dragging in the JSON file.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;customization-options&quot;&gt;Customization Options&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Once the form opens, click the &lt;strong&gt;Import JSON&lt;/strong&gt; file if you have saved an existing JSON file from a previous query and want to reuse it as the starting point for a new query.&lt;/li&gt;
&lt;li&gt;In the &lt;strong&gt;Custom Fields&lt;/strong&gt; area, deactivate any fields not relevant to your query. Active field buttons have a dark background; whereas, deactivated field buttons have a light background. Any deactivated field can be re-activated by clicking its associated button.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;json-output-sample&quot;&gt;JSON Output Sample&lt;/h2&gt;
&lt;p&gt;Your generated JSON will be similar to this:&lt;/p&gt;
&lt;pre class=&quot;language-json&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-json&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;instructions&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Process and respond to this prompt.&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;role&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;You are an experienced data analyst specializing in retail performance.&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;context&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;You are analyzing Q4 2024 sales data for a mid-sized retailer operating in North America.&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;task&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Identify the top three sales trends and provide insight into what factors may have contributed to these patterns.&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;format&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Present your findings as three concise bullet points, each with one supporting sentence.&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;examples&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;- Example Trend: Seasonal spike in apparel sales due to holiday promotions.&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;constraints&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Focus only on quantitative insights supported by data. Avoid speculation not backed by sales metrics.&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;data&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;region,sales,transactions North America,1200000,32000 Europe,900000,28000 Asia,1100000,30000&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;audience&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Retail operations managers looking for actionable insights to guide Q1 2025 planning.&quot;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;instructions&lt;/code&gt; key/value tells the LLM what to do with the JSON content. It is included, automatically.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Prompt Efficiencies</title>
    <link href="https://shealy2020.github.io/posts/prompt-efficiencies/" />
    <updated>2025-08-15T00:00:00Z</updated>
    <id>https://shealy2020.github.io/posts/prompt-efficiencies/</id>
    <content type="html">&lt;h2 id=&quot;tokens&quot;&gt;Tokens&lt;/h2&gt;
&lt;p&gt;A token is a small chunk of text that the AI model uses to process your message and generate a reply. Both what you enter and what the model sends back count toward your token limit. When you write short, focused prompts and ask for concise answers, you use fewer tokens overall. That means your sessions can last longer, responses come faster, and you’re less likely to hit token limits or get cut off mid-reply.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Conserve tokens = longer sessions + faster responses + fewer cutoffs&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-prompt-design&quot;&gt;1️. Prompt Design&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Do&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Keep prompts concise: use direct verbs (“summarize,” “revise,” “explain briefly”).&lt;/li&gt;
&lt;li&gt;Reference earlier text instead of re-pasting it.&lt;/li&gt;
&lt;li&gt;State the &lt;em&gt;output size&lt;/em&gt;:
&lt;ul&gt;
&lt;li&gt;“In 3 bullet points.”&lt;/li&gt;
&lt;li&gt;“Under 100 words.”&lt;/li&gt;
&lt;li&gt;“Code only—no explanation.”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Don’t&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Repeat long setup text (“As I mentioned earlier…”).&lt;/li&gt;
&lt;li&gt;Ask for multiple tasks in one prompt if they can be done sequentially.&lt;/li&gt;
&lt;li&gt;Use filler (“Could you please kindly explain…”).&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;2-conversation-management&quot;&gt;2. Conversation Management&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Stay in the same chat thread so context persists.&lt;/li&gt;
&lt;li&gt;Split long projects:
&lt;ol&gt;
&lt;li&gt;Outline&lt;/li&gt;
&lt;li&gt;Draft one part&lt;/li&gt;
&lt;li&gt;Revise iteratively&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Delete or summarize unneeded sections before continuing.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;3-handling-large-text&quot;&gt;3️. Handling Large Text&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Paste &lt;strong&gt;only relevant sections&lt;/strong&gt; (“Here’s the last 30 lines”).&lt;/li&gt;
&lt;li&gt;Summarize before submission (“This 20-page doc covers X, Y, Z…”).&lt;/li&gt;
&lt;li&gt;Use &lt;strong&gt;compressed summaries&lt;/strong&gt; or keywords when possible.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;4-service-specific-tips&quot;&gt;4. Service-Specific Tips&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Service&lt;/th&gt;
&lt;th&gt;Efficiency Tactics&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;ChatGPT&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;GPT-4o’s tokenizer is efficient. Reuse previous messages and cap outputs.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Claude&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Takes long input well — summarize documents instead of feeding full text.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Gemini&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Large window; main limit is requests/day. Keep prompts precise and output short.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&quot;5-output-control&quot;&gt;5️. Output Control&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Ask for &lt;strong&gt;structured formats&lt;/strong&gt; (Markdown, table, JSON).&lt;/li&gt;
&lt;li&gt;Set maximums:
&lt;ul&gt;
&lt;li&gt;“Explain in ≤5 sentences.”&lt;/li&gt;
&lt;li&gt;“Show first 10 lines only.”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;For code: “Return only the function definition.”&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;approximate-token-use&quot;&gt;Approximate Token Use&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Word Count&lt;/th&gt;
&lt;th&gt;≈ Tokens&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;75 words&lt;/td&gt;
&lt;td&gt;~100 tokens&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;500 words&lt;/td&gt;
&lt;td&gt;~650 tokens&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1,000 words&lt;/td&gt;
&lt;td&gt;~1,300 tokens&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Goal:&lt;/strong&gt; Short, direct, scoped prompts → 3–5× token savings.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Generating Information Products with RAG</title>
    <link href="https://shealy2020.github.io/posts/doc-gen-rag-pipeline/" />
    <updated>2025-08-10T00:00:00Z</updated>
    <id>https://shealy2020.github.io/posts/doc-gen-rag-pipeline/</id>
    <content type="html">&lt;p&gt;This document explains how a Retrieval-Augmented Generation (RAG) pipeline processes local documents to generate new information products.&lt;/p&gt;
&lt;p&gt;The RAG architecture operates as a set of coordinated components—each performing a specific function such as ingestion, embedding, retrieval, or generation. Some of these functions are handled by open-source tools or libraries, while others are implemented as in-house modules or scripts.&lt;/p&gt;
&lt;h2 id=&quot;rag-pipeline-diagram&quot;&gt;RAG Pipeline Diagram&lt;/h2&gt;
&lt;figure&gt;
&lt;img src=&quot;https://shealy2020.github.io/images/rag-pipeline-diagram.svg&quot; alt=&quot;RAG Pipeline Diagram&quot;&gt;
  &lt;figcaption&gt;RAG Pipeline Diagram&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h2 id=&quot;1-preparing-source-documents&quot;&gt;1. Preparing Source Documents&lt;/h2&gt;
&lt;p&gt;The RAG pipeline begins by scanning a designated directory to identify source documents. This scanning typically starts with a file discovery script or scheduling system—such as Apache Airflow, Cron, or Haystack’s indexing API—that monitors a local or shared directory for new or updated files. The pipeline performs this initial scan to locate every file in the defined repository that should become part of the knowledge base. It uses file-matching patterns and metadata filters to include only relevant document types, such as manuals, technical notes, or reports. The system usually triggers this step on a schedule or when new files appear in the target directory, ensuring continuous synchronization between storage and the AI knowledge layer.&lt;/p&gt;
&lt;p&gt;These files can include manuals, technical notes, reports, or other text sources that the organization wants to make retrievable. The ingestion module (for example, Apache Tika or Haystack), which collects files, reads their contents, and extracts text from multiple formats, identifies and removes unnecessary markup, images, or formatting tags. It prepares a clean text stream that the rest of the RAG process can interpret efficiently.&lt;/p&gt;
&lt;p&gt;Next, the pipeline standardizes the text using a normalization process that applies text-cleaning and formatting operations with libraries such as spaCy, NLTK, or regex-based scripts. The normalization stage runs before semantic processing so that every document entering the embedding phase follows the same linguistic and formatting conventions. It converts text into a common encoding such as UTF-8 and removes extraneous spaces and symbols. This step ensures that later stages handle data predictably across operating systems and file types. The normalization typically occurs right after ingestion, before any chunking or semantic processing begins.&lt;/p&gt;
&lt;p&gt;After normalization, the ingestion module segments the document logically. Segmentation defines boundaries between sections based on headings, paragraph breaks, or structural cues such as Markdown or HTML tags. Segmentation and chunking differ in both purpose and scale: segmentation organizes long documents into logical sections for readability, while chunking later divides those sections into smaller semantic units that fit within the LLM’s context window. By identifying these boundaries early, the ingestion module helps preserve document meaning and prepares each section for chunking.&lt;/p&gt;
&lt;p&gt;The chunking engine—often implemented through frameworks such as LangChain or Haystack—divides documents into smaller, meaning-preserving units for semantic analysis. Although LangChain and Haystack are not dedicated chunking engines, both provide utilities for text splitting as part of their document-processing pipelines. These functions split text based on sentence structure, paragraph boundaries, or token counts to prepare data for embedding. Chunking exists to make large documents computationally manageable, ensuring that each chunk fits within the token limits of downstream models. The chunking engine ensures that each chunk contains enough context for accurate retrieval but still fits within the &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#context-window&quot;&gt;context window&lt;/a&gt; of the &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#llm&quot;&gt;LLM&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The RAG architecture assigns a unique identifier to each chunk and logs its source document and location through an orchestration or metadata management component—often part of the ingestion pipeline itself or managed through tools like Elasticsearch or Haystack’s DocumentStore. This component tracks where each chunk originated and when it was last updated, ensuring traceability and version control. The processed chunks move to temporary storage, where the pipeline holds them before conversion into mathematical representations such as embeddings.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Summary:&lt;/strong&gt; At the end of this phase, the RAG pipeline transforms unstructured files into clean, segmented text units that can be consistently processed by later components. These chunks provide the traceable foundation for semantic understanding.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;2-creating-embeddings-and-vectors&quot;&gt;2. Creating Embeddings and Vectors&lt;/h2&gt;
&lt;p&gt;The embedding model now converts each chunk into an &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#embeddings&quot;&gt;embedding&lt;/a&gt;. An embedding model (for example, SentenceTransformers or OpenAI’s text-embedding models) maps text into a numerical space where meaning corresponds to distance. These models are smaller, task-specific neural networks that have been fine-tuned for text similarity tasks and can run locally or as an API service. This process translates language into mathematical form, preserving semantic relationships among sentences and phrases. The closer two embeddings are in this space, the more similar their meanings.&lt;/p&gt;
&lt;p&gt;Each embedding becomes a &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#vector&quot;&gt;vector&lt;/a&gt;. The vector encodes the meaning of a chunk in high-dimensional space—an abstract mathematical representation in which each dimension corresponds to a latent linguistic feature such as context, topic, or tone. Instead of three familiar spatial axes, these vectors can have hundreds or thousands of dimensions, allowing the system to capture subtle semantic differences. The embedding model ensures that semantically similar text produces vectors that occupy nearby positions, while unrelated text produces distant vectors. This mathematical organization allows semantic search by meaning rather than by keyword.&lt;/p&gt;
&lt;p&gt;The ingestion module in this phase acts as a processing pipeline that manages data flow between embedding and storage components. In frameworks such as Haystack or LangChain, this module orchestrates embedding generation, batching, and submission to storage systems. Batching minimizes overhead by grouping multiple embeddings into a single write operation. The vector database (such as FAISS, Weaviate, or Chroma) stores these vectors, enabling high-speed comparison operations. The ingestion module links each stored vector with metadata that identifies its source and chunk ID.&lt;/p&gt;
&lt;p&gt;Once stored, the vectors become searchable entities. The retrieval engine (for example, Haystack’s Retriever or LangChain’s VectorStoreRetriever) can now measure similarity between vectors using distance metrics such as &lt;a href=&quot;https://en.wikipedia.org/wiki/Cosine_similarity&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cosine similarity&lt;/a&gt;. This measurement quantifies how much two text passages share conceptual meaning, supporting accurate retrieval even when wording differs. The retrieval engine later uses these relationships to locate relevant chunks when users submit queries.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Summary:&lt;/strong&gt; This stage translates human-readable text into machine-readable meaning. By encoding chunks into embeddings and vectors, the system builds the mathematical structure that enables semantic search and knowledge retrieval.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;3-indexing-and-metadata&quot;&gt;3. Indexing and Metadata&lt;/h2&gt;
&lt;p&gt;The vector database management component builds an &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#indexing&quot;&gt;index&lt;/a&gt; over the database to enable efficient similarity searches. The index organizes vectors according to proximity and dimension. Tools such as FAISS and Milvus implement these indices using approximate nearest neighbor algorithms. The indexing mechanism allows fast lookups without scanning every stored vector, making large-scale semantic search feasible. The indexing structure allows the retrieval engine to locate the most relevant vectors rapidly, even when datasets scale into millions of entries.&lt;/p&gt;
&lt;p&gt;During indexing, the ingestion process adds &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#vector-metadata&quot;&gt;vector metadata&lt;/a&gt;. Metadata stores key attributes such as file name, author, and timestamp, ensuring that the origin of every chunk remains known. This data supports filtering, relevance scoring, and regulatory compliance by preserving the document source. It also enables users to request only specific document types or time periods when generating outputs.&lt;/p&gt;
&lt;p&gt;The RAG architecture maintains and updates the index dynamically. Whenever a document changes, the pipeline reprocesses its affected chunks, regenerates embeddings, and replaces outdated vectors. These updates often run through scheduled batch jobs or file-system triggers that detect changes in source content, ensuring the knowledge base remains synchronized. This automatic updating prevents information drift, ensuring that every retrieved vector reflects the most current version of its source text.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Summary:&lt;/strong&gt; Indexing and metadata management create a living, searchable map of organizational knowledge. The system continually refreshes this index to keep semantic retrieval accurate and up to date.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;4-user-queries-and-retrieval&quot;&gt;4. User Queries and Retrieval&lt;/h2&gt;
&lt;p&gt;When a user submits a question or request, the RAG pipeline processes it as input to the embedding model. In this context, “the model” refers to the same embedding model used earlier for document chunks—such as SentenceTransformers or MiniLM—so that both the query and stored chunks exist in the same semantic space. Using the same model for both documents and queries ensures that their numerical representations are directly comparable.&lt;/p&gt;
&lt;p&gt;The retrieval engine (for example, Haystack or LangChain retrievers), which searches the indexed vector space for the most semantically related chunks, compares the query embedding against all stored vectors. It computes similarity scores and ranks the results. The engine retrieves the top-matching chunks with their metadata, ensuring that only the most relevant information proceeds to generation.&lt;/p&gt;
&lt;p&gt;The retrieval engine packages these chunks into a response set. It adds provenance data—structured information that records the document ID, source location, author, and timestamp for each retrieved chunk, allowing reviewers to trace every output back to its origin and confirm its authenticity—which maintains transparency and allows auditing. This provenance information not only supports compliance but also allows iterative refinement, as teams can trace which documents most frequently influence AI outputs. The pipeline then passes this packaged context to the &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#llm&quot;&gt;LLM&lt;/a&gt;. The LLM depends entirely on these retrieved chunks to create an informed, fact-based response.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Summary:&lt;/strong&gt; Query processing transforms user intent into a semantic search task. The retrieval engine uses vector similarity to identify and deliver the most relevant context for generation.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;5-prompting-and-response-generation&quot;&gt;5. Prompting and Response Generation&lt;/h2&gt;
&lt;p&gt;After retrieval, the prompt construction module builds a &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#prompt&quot;&gt;prompt&lt;/a&gt; that includes the user’s question, the retrieved chunks, and formatting instructions. The module arranges these elements so that the most relevant context appears first, maximizing the LLM’s attention on key details. Prompt construction is typically implemented with orchestration frameworks such as LangChain or LlamaIndex, which dynamically assemble retrieved text into templates that guide the model’s reasoning. This preparation step determines how effectively the model can answer complex or multi-part queries.&lt;/p&gt;
&lt;p&gt;The LLM reads the prompt within its &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#context-window&quot;&gt;context window&lt;/a&gt;. It analyzes the text, identifies linguistic and logical patterns, and synthesizes new language grounded in the provided content. The LLM cannot access external data because it operates in a self-contained inference environment without network connectivity or live database access; it can only use the context explicitly provided in the prompt. Prompt quality directly determines output accuracy and completeness.&lt;/p&gt;
&lt;p&gt;The generation process produces new text that answers the query or repackages knowledge into the requested format. The LLM may rewrite, summarize, or create structured documents based on its instructions. The RAG pipeline monitors this output using validation scripts or rule-based checks (for example, LangChain output parsers) to confirm that responses follow organizational standards and formatting policies.&lt;/p&gt;
&lt;p&gt;The quality of the generated output depends entirely on retrieval accuracy. If the retrieved information is incomplete, the LLM may generate incorrect conclusions. Human reviewers typically evaluate outputs for clarity and factual reliability before final publication, ensuring accountability. This human validation step closes the loop between automation and human editorial oversight.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Summary:&lt;/strong&gt; The prompt and generation stages translate retrieved knowledge into coherent, formatted text. Validation ensures that automated writing remains accurate and consistent with verified sources.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;6-putting-it-all-together&quot;&gt;6. Putting It All Together&lt;/h2&gt;
&lt;p&gt;The entire workflow—retrieving semantically relevant chunks from a vector database and providing them to an LLM for output generation—defines the &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#rag&quot;&gt;RAG&lt;/a&gt; approach. RAG combines a search process that finds the right information with a writing process that converts that information into clear text. Retrieval anchors responses in verified data, meaning content that comes directly from authenticated and traceable internal documents rather than the model’s pretraining. Generation converts that data into readable, natural language.&lt;/p&gt;
&lt;p&gt;The RAG pipeline continuously evolves. When new documents are added, the system triggers ingestion, embedding, and indexing automatically, ensuring the knowledge base stays synchronized with the file system. This automation allows organizations to keep AI-generated content aligned with their latest internal documentation without reconfiguring the system or retraining the model.&lt;/p&gt;
&lt;p&gt;By maintaining separate retrieval and generation components, the RAG architecture enforces data governance. Retrieval provides control over the factual foundation, and generation handles expression and structure, allowing organizations to trace the origin of each generated statement through metadata links and provenance records stored with the source chunks. These traceable records help auditors and knowledge managers verify how outputs were created.&lt;/p&gt;
&lt;p&gt;When operating effectively, the RAG pipeline turns static document collections into searchable knowledge systems that produce accurate, contextually grounded, and auditable outputs. At this point, the workflow forms a complete feedback cycle: documents become data, data becomes knowledge, and knowledge becomes reusable assets for future AI-driven documentation.&lt;/p&gt;
&lt;hr&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Open-source Tools or Frameworks Referenced&lt;/th&gt;
&lt;th&gt;Function&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://tika.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Apache Tika&lt;/a&gt;, &lt;a href=&quot;https://haystack.deepset.ai/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Haystack&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;File ingestion &amp;amp; parsing&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://airflow.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Apache Airflow&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Cron&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cron&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Scheduling / automation&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://spacy.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;spaCy&lt;/a&gt;, &lt;a href=&quot;https://www.nltk.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NLTK&lt;/a&gt;, regex scripts&lt;/td&gt;
&lt;td&gt;Text normalization&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://www.langchain.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LangChain&lt;/a&gt;, &lt;a href=&quot;https://haystack.deepset.ai/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Haystack DocumentSplitter&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Chunking&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://www.sbert.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SentenceTransformers&lt;/a&gt;, &lt;a href=&quot;https://huggingface.co/sentence-transformers/all-MiniLM-L6-v2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MiniLM&lt;/a&gt;, &lt;a href=&quot;https://platform.openai.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OpenAI API&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Embedding generation&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/facebookresearch/faiss&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FAISS&lt;/a&gt;, &lt;a href=&quot;https://weaviate.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Weaviate&lt;/a&gt;, &lt;a href=&quot;https://milvus.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Milvus&lt;/a&gt;, &lt;a href=&quot;https://www.trychroma.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Chroma&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Vector storage &amp;amp; indexing&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://haystack.deepset.ai/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Haystack Retriever&lt;/a&gt;, &lt;a href=&quot;https://www.langchain.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LangChain VectorStore&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Retrieval engine&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://www.llamaindex.ai/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LlamaIndex&lt;/a&gt;, &lt;a href=&quot;https://www.langchain.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LangChain PromptTemplate&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Prompt orchestration&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://www.langchain.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LangChain Output Parsers&lt;/a&gt;, rule-based checks&lt;/td&gt;
&lt;td&gt;Validation &amp;amp; parsing&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</content>
  </entry>
  <entry>
    <title>RAG Pipeline Terms</title>
    <link href="https://shealy2020.github.io/posts/ai-terms-glossary/" />
    <updated>2025-08-10T00:00:00Z</updated>
    <id>https://shealy2020.github.io/posts/ai-terms-glossary/</id>
    <content type="html">&lt;h2 id=&quot;chunks&quot;&gt;Chunks&lt;/h2&gt;
&lt;p&gt;Chunks are small, meaningful segments of text derived from larger documents. Each chunk represents a coherent piece of information suitable for analysis by the AI system. Chunks are converted into &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#embeddings&quot;&gt;embeddings&lt;/a&gt;, allowing semantic comparison between pieces of text. Chunk size affects how well the system captures meaning. Chunking ensures that even large documents can be represented and retrieved efficiently.&lt;/p&gt;
&lt;h2 id=&quot;context-window&quot;&gt;Context Window&lt;/h2&gt;
&lt;p&gt;The context window is the limit on how much text an &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#llm&quot;&gt;LLM&lt;/a&gt; can read at one time. Every word or symbol the model processes counts toward this limit as &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#tokens&quot;&gt;tokens&lt;/a&gt;. If too much text is included, the system must choose which chunks to include in the &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#prompt&quot;&gt;prompt&lt;/a&gt;. This choice affects output accuracy. Understanding context windows ensures that relevant material is prioritized for generation.&lt;/p&gt;
&lt;h2 id=&quot;cosine-similarity&quot;&gt;Cosine Similarity&lt;/h2&gt;
&lt;p&gt;Cosine similarity is a metric used to measure how similar two vectors are by calculating the cosine of the angle between them in a multi-dimensional space. It ranges from -1 to 1, where 1 indicates the vectors point in exactly the same direction (most similar), 0 indicates they are orthogonal (unrelated), and -1 indicates they point in opposite directions (most dissimilar). In practice, particularly for text embeddings and natural language processing, cosine similarity is widely used because it focuses on the orientation of vectors rather than their magnitude, making it effective for comparing documents or word embeddings regardless of their length. This property makes it especially valuable in information retrieval systems and recommendation engines, where the goal is to find content that is semantically similar to a query or reference item.&lt;/p&gt;
&lt;h2 id=&quot;embeddings&quot;&gt;Embeddings&lt;/h2&gt;
&lt;p&gt;Embeddings are numerical representations of text. Each &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#chunks&quot;&gt;chunk&lt;/a&gt; becomes an embedding that captures its semantic meaning as a &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#vector&quot;&gt;vector&lt;/a&gt;. By comparing embeddings, the system can determine &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#semantic-similarity&quot;&gt;semantic similarity&lt;/a&gt; between different pieces of text. This enables retrieval of conceptually related information even if exact wording differs. Embeddings are central to connecting text meaning with mathematical structure.&lt;/p&gt;
&lt;h2 id=&quot;generator&quot;&gt;Generator&lt;/h2&gt;
&lt;p&gt;The generator is the stage where the &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#llm&quot;&gt;LLM&lt;/a&gt; produces new text from the retrieved context. It synthesizes content from the &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#prompt&quot;&gt;prompt&lt;/a&gt; and organizes it into a coherent response. The generator applies its learned patterns of language to express retrieved facts accurately and clearly. This process completes the transformation of static data into new information products.&lt;/p&gt;
&lt;h2 id=&quot;hallucination&quot;&gt;Hallucination&lt;/h2&gt;
&lt;p&gt;Hallucination occurs when an &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#llm&quot;&gt;LLM&lt;/a&gt; generates information not supported by retrieved context. It may result from irrelevant or incomplete data retrieval. While retrieval-based systems reduce this risk, human review remains essential for quality assurance. Hallucination highlights the importance of grounding generative output in verified data.&lt;/p&gt;
&lt;p&gt;While each chunk includes provenance data, the LLM may sometimes blend retrieved facts with its learned linguistic patterns, producing statements that seem factual but lack an exact source match. These mismatches occur because the model generates plausible language rather than verifying data against the index. Continuous validation, feedback tuning, and human review are essential to reduce, but not eliminate, this risk of hallucinations.&lt;/p&gt;
&lt;h2 id=&quot;indexing&quot;&gt;Indexing&lt;/h2&gt;
&lt;p&gt;Indexing is the process of scanning files in the knowledge base and preparing them for processing. Each document is analyzed for text content, structure, and context. The result of indexing is a set of &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#chunks&quot;&gt;chunks&lt;/a&gt; that are later converted into &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#embeddings&quot;&gt;embeddings&lt;/a&gt;. Metadata such as document name or modification date is also stored for future filtering. Indexing enables the AI system to organize data for efficient retrieval and reuse.&lt;/p&gt;
&lt;h2 id=&quot;inference&quot;&gt;Inference&lt;/h2&gt;
&lt;p&gt;Inference is the process of producing output from a trained &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#llm&quot;&gt;LLM&lt;/a&gt; based on a &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#prompt&quot;&gt;prompt&lt;/a&gt;. It represents the execution phase where the model interprets embeddings and context to form a final text output. Inference turns the retrieved knowledge into language that users can read and use.&lt;/p&gt;
&lt;h2 id=&quot;knowledge-base&quot;&gt;Knowledge Base&lt;/h2&gt;
&lt;p&gt;The knowledge base is the collection of documents available for AI processing. It can include structured files such as spreadsheets or unstructured files such as text documents or PDFs. During indexing, these files are scanned and analyzed so that their content can be represented as &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#chunks&quot;&gt;chunks&lt;/a&gt;. Each chunk carries contextual information through &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#vector-metadata&quot;&gt;metadata&lt;/a&gt;, which helps track its source and meaning.The knowledge base provides the foundation for document retrieval and generation within a RAG system.&lt;/p&gt;
&lt;h2 id=&quot;large-language-model-llm&quot;&gt;Large Language Model (LLM)&lt;/h2&gt;
&lt;p&gt;It&#39;s crucial to understand what the LLM does and doesn&#39;t do. The LLM is not a database. It doesn&#39;t store your company&#39;s documentation or &amp;quot;memorize&amp;quot; facts. Instead, think of it as a highly skilled editor who can read source material you provide and rewrite it into different formats while maintaining accuracy.&lt;/p&gt;
&lt;p&gt;When the LLM generates documentation, it&#39;s reading the chunks you retrieved and transforming them—similar to how you might read several related sections and synthesize them into a single document. The LLM has learned patterns of language from its training, so it knows how to structure sentences and organize sections. But every fact in its output should come from the context you provided.&lt;/p&gt;
&lt;p&gt;This is why retrieval is so important. If the system retrieves the wrong chunks, the LLM will generate based on incorrect data. The LLM can also experience &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#hallucination&quot;&gt;hallucination&lt;/a&gt;, where it confidently states information not present in the provided context.&lt;/p&gt;
&lt;h2 id=&quot;prompt&quot;&gt;Prompt&lt;/h2&gt;
&lt;p&gt;A prompt is the input given to the &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#llm&quot;&gt;LLM&lt;/a&gt;. It includes the user&#39;s request and the most relevant chunks retrieved from the &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#vector-database&quot;&gt;vector database&lt;/a&gt;. The quality of the prompt determines the accuracy and clarity of the generated result. A well-constructed prompt keeps context within the &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#context-window&quot;&gt;context window&lt;/a&gt;. Prompt construction is key to aligning retrieval output with generative performance.&lt;/p&gt;
&lt;h2 id=&quot;query-embedding&quot;&gt;Query Embedding&lt;/h2&gt;
&lt;p&gt;A query embedding is the vector form of a user&#39;s request. It is created in the same way as document &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#embeddings&quot;&gt;embeddings&lt;/a&gt;, allowing direct comparison in the &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#vector-database&quot;&gt;vector database&lt;/a&gt;. The &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#retriever&quot;&gt;retriever&lt;/a&gt; uses this embedding to find document chunks most similar in meaning to the query. This mechanism ensures that the LLM receives contextually relevant information for generation.&lt;/p&gt;
&lt;h2 id=&quot;retrieval-augmented-generation-rag&quot;&gt;Retrieval-Augmented Generation (RAG)&lt;/h2&gt;
&lt;p&gt;Retrieval-Augmented Generation (RAG) combines retrieval of stored knowledge with generative modeling. It ensures that the &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#llm&quot;&gt;LLM&lt;/a&gt; bases its responses on relevant, factual data. The &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#retriever&quot;&gt;retriever&lt;/a&gt; finds matching chunks, and the &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#generator&quot;&gt;generator&lt;/a&gt; creates new text using that context. This integration reduces &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#hallucination&quot;&gt;hallucination&lt;/a&gt; and improves factual reliability. RAG connects storage, retrieval, and generation into a unified process.&lt;/p&gt;
&lt;h2 id=&quot;retriever&quot;&gt;Retriever&lt;/h2&gt;
&lt;p&gt;The retriever searches the &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#vector-database&quot;&gt;vector database&lt;/a&gt; for document chunks most semantically similar to the &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#query-embedding&quot;&gt;query embedding&lt;/a&gt;. It selects a limited number of chunks that best match the user’s request, based on &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#semantic-similarity&quot;&gt;semantic similarity&lt;/a&gt;. The retriever forms the bridge between stored knowledge and generative processing.&lt;/p&gt;
&lt;h2 id=&quot;semantic-similarity&quot;&gt;Semantic Similarity&lt;/h2&gt;
&lt;p&gt;Semantic similarity measures how closely two &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#embeddings&quot;&gt;embeddings&lt;/a&gt; represent the same meaning. It is often computed using &lt;a href=&quot;https://en.wikipedia.org/wiki/Cosine_similarity&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cosine similarity&lt;/a&gt;. By comparing embeddings numerically, the system can retrieve information related in meaning rather than identical in wording. Semantic similarity enables the retrieval step in the RAG process.&lt;/p&gt;
&lt;h2 id=&quot;tokens&quot;&gt;Tokens&lt;/h2&gt;
&lt;p&gt;Tokens are the smallest text units an &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#llm&quot;&gt;LLM&lt;/a&gt; processes, roughly corresponding to words or word fragments. The number of tokens determines how much content fits within the &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#context-window&quot;&gt;context window&lt;/a&gt;. Managing tokens helps control both response length and computational cost.Tokens are the measurement unit for how the model reads and generates text.&lt;/p&gt;
&lt;h2 id=&quot;vector&quot;&gt;Vector&lt;/h2&gt;
&lt;p&gt;A vector is a list of numbers representing the meaning of text in mathematical form. Each &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#embeddings&quot;&gt;embedding&lt;/a&gt; is stored as a vector in a high-dimensional space. The distance between two vectors indicates how similar their meanings are, often measured by &lt;a href=&quot;https://en.wikipedia.org/wiki/Cosine_similarity&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cosine similarity&lt;/a&gt;. Vectors make it possible for computers to perform semantic comparisons across large document sets.&lt;/p&gt;
&lt;h2 id=&quot;vector-database&quot;&gt;Vector Database&lt;/h2&gt;
&lt;p&gt;A vector database stores &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#vector&quot;&gt;vectors&lt;/a&gt; and their associated &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#vector-metadata&quot;&gt;metadata&lt;/a&gt;. It enables rapid search based on &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#semantic-similarity&quot;&gt;semantic similarity&lt;/a&gt; rather than keyword matching. When a user query is received, the database is searched for vectors most similar to the &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#query-embedding&quot;&gt;query embedding&lt;/a&gt;. The retrieved chunks are then passed to the LLM for generation. Vector databases are optimized for large-scale similarity searches.&lt;/p&gt;
&lt;h2 id=&quot;vector-metadata&quot;&gt;Vector Metadata&lt;/h2&gt;
&lt;p&gt;Vector metadata refers to information stored alongside each &lt;a href=&quot;https://shealy2020.github.io/posts/ai-terms-glossary/#vector&quot;&gt;vector&lt;/a&gt;, such as the original file name, section title, or timestamp. Metadata allows filtering or ranking retrieved results to ensure the system selects the most relevant and current content. This layer maintains traceability from generated text back to its original source.&lt;/p&gt;
</content>
  </entry>
</feed>